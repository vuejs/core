// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`SFC analyze <script> bindings > auto name inference > basic 1`] = `
"const a = 1
export default {
  __name: 'FooBar',
  setup(__props, { expose: __expose }) {
  __expose();

return { a }
}

}"
`;

exports[`SFC analyze <script> bindings > auto name inference > do not overwrite manual name (call) 1`] = `
"import { defineComponent } from 'vue'
        const __default__ = defineComponent({
          name: 'Baz'
        })
        
export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();
const a = 1
return { a, defineComponent }
}

})"
`;

exports[`SFC analyze <script> bindings > auto name inference > do not overwrite manual name (object) 1`] = `
"const __default__ = {
          name: 'Baz'
        }
        
export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();
const a = 1
return { a }
}

})"
`;

exports[`SFC compile <script setup> > <script> after <script setup> the script content not end with \`\\n\` 1`] = `
"import { x } from './x'
    const n = 1

export default {
  setup(__props, { expose: __expose }) {
  __expose();

    
return { n, get x() { return x } }
}

}"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > export call expression as default 1`] = `
"function fn() {
        return \\"hello, world\\";
      }
      const __default__ = fn();
      
export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

      console.log('foo')
      
return { fn }
}

})"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > script first 1`] = `
"import { x } from './x'
      
      export const n = 1

      const __default__ = {}
      
export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

      x()
      
return { n, get x() { return x } }
}

})"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > script setup first 1`] = `
"import { x } from './x'
      
      export const n = 1
      const __default__ = {}
      

export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

      x()
      
return { n, get x() { return x } }
}

})"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > script setup first, lang="ts", script block content export default 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { x } from './x'
      
      const __default__ = {
        name: \\"test\\"
      }
      

export default /*#__PURE__*/_defineComponent({
  ...__default__,
  setup(__props, { expose: __expose }) {
  __expose();

      x()
      
return { get x() { return x } }
}

})"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > script setup first, named default export 1`] = `
"import { x } from './x'
      
      export const n = 1
      const def = {}
      
      
const __default__ = def


export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

      x()
      
return { n, def, get x() { return x } }
}

})"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > spaces in ExportDefaultDeclaration node > with many spaces and newline 1`] = `
"import { x } from './x'
        
        export const n = 1
        const __default__ = {
          some:'option'
        }
        
export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

        x()
        
return { n, get x() { return x } }
}

})"
`;

exports[`SFC compile <script setup> > <script> and <script setup> co-usage > spaces in ExportDefaultDeclaration node > with minimal spaces 1`] = `
"import { x } from './x'
        
        export const n = 1
        const __default__ = {
          some:'option'
        }
        
export default /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

        x()
        
return { n, get x() { return x } }
}

})"
`;

exports[`SFC compile <script setup> > async/await detection > expression statement 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
;(
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  await __temp,
  __restore()
)
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > multiple \`if for\` nested statements 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
if (ok) {
        for (let a of [1,2,3]) {
          (
  ([__temp,__restore] = _withAsyncContext(() => a)),
  await __temp,
  __restore()
)
        }
        for (let a of [1,2,3]) {
          (
  ([__temp,__restore] = _withAsyncContext(() => a)),
  await __temp,
  __restore()
)
          ;(
  ([__temp,__restore] = _withAsyncContext(() => a)),
  await __temp,
  __restore()
)
        }
      }
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > multiple \`if while\` nested statements 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
if (ok) {
        while (d) {
          (
  ([__temp,__restore] = _withAsyncContext(() => 5)),
  await __temp,
  __restore()
)
        }
        while (d) {
          (
  ([__temp,__restore] = _withAsyncContext(() => 5)),
  await __temp,
  __restore()
)
          ;(
  ([__temp,__restore] = _withAsyncContext(() => 6)),
  await __temp,
  __restore()
)
          if (c) {
            let f = 10
            10 + (
  ([__temp,__restore] = _withAsyncContext(() => 7)),
  __temp = await __temp,
  __restore(),
  __temp
)
          } else {
            (
  ([__temp,__restore] = _withAsyncContext(() => 8)),
  await __temp,
  __restore()
)
            ;(
  ([__temp,__restore] = _withAsyncContext(() => 9)),
  await __temp,
  __restore()
)
          }
        }
      }
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > multiple \`if\` nested statements 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
if (ok) {
        let a = 'foo'
        ;(
  ([__temp,__restore] = _withAsyncContext(() => 0)),
  __temp = await __temp,
  __restore(),
  __temp
) + (
  ([__temp,__restore] = _withAsyncContext(() => 1)),
  __temp = await __temp,
  __restore(),
  __temp
)
        ;(
  ([__temp,__restore] = _withAsyncContext(() => 2)),
  await __temp,
  __restore()
)
      } else if (a) {
        (
  ([__temp,__restore] = _withAsyncContext(() => 10)),
  await __temp,
  __restore()
)
        if (b) {
          (
  ([__temp,__restore] = _withAsyncContext(() => 0)),
  __temp = await __temp,
  __restore(),
  __temp
) + (
  ([__temp,__restore] = _withAsyncContext(() => 1)),
  __temp = await __temp,
  __restore(),
  __temp
)
        } else {
          let a = 'foo'
          ;(
  ([__temp,__restore] = _withAsyncContext(() => 2)),
  await __temp,
  __restore()
)
        }
        if (b) {
          (
  ([__temp,__restore] = _withAsyncContext(() => 3)),
  await __temp,
  __restore()
)
          ;(
  ([__temp,__restore] = _withAsyncContext(() => 4)),
  await __temp,
  __restore()
)
        }
      } else {
        (
  ([__temp,__restore] = _withAsyncContext(() => 5)),
  await __temp,
  __restore()
)
      }
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > nested await 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
;(
  ([__temp,__restore] = _withAsyncContext(async () => ((
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  __temp = await __temp,
  __restore(),
  __temp
)))),
  await __temp,
  __restore()
)
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > nested await 2`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
;(
  ([__temp,__restore] = _withAsyncContext(async () => (((
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  __temp = await __temp,
  __restore(),
  __temp
))))),
  await __temp,
  __restore()
)
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > nested await 3`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
;(
  ([__temp,__restore] = _withAsyncContext(async () => ((
  ([__temp,__restore] = _withAsyncContext(async () => ((
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  __temp = await __temp,
  __restore(),
  __temp
)))),
  __temp = await __temp,
  __restore(),
  __temp
)))),
  await __temp,
  __restore()
)
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > nested leading await in expression statement 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
foo()
;(
  ([__temp,__restore] = _withAsyncContext(() => 1)),
  __temp = await __temp,
  __restore(),
  __temp
) + (
  ([__temp,__restore] = _withAsyncContext(() => 2)),
  __temp = await __temp,
  __restore(),
  __temp
)
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > nested statements 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
if (ok) { (
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  await __temp,
  __restore()
) } else { (
  ([__temp,__restore] = _withAsyncContext(() => bar)),
  await __temp,
  __restore()
) }
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > ref 1`] = `
"import { withAsyncContext as _withAsyncContext, ref as _ref } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
let a = _ref(1 + ((
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  __temp = await __temp,
  __restore(),
  __temp
)))
return { a }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > should ignore await inside functions 1`] = `
"export default {
  setup(__props, { expose: __expose }) {
  __expose();
async function foo() { await bar }
return { foo }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > should ignore await inside functions 2`] = `
"export default {
  setup(__props, { expose: __expose }) {
  __expose();
const foo = async () => { await bar }
return { foo }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > should ignore await inside functions 3`] = `
"export default {
  setup(__props, { expose: __expose }) {
  __expose();
const obj = { async method() { await bar }}
return { obj }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > should ignore await inside functions 4`] = `
"export default {
  setup(__props, { expose: __expose }) {
  __expose();
const cls = class Foo { async method() { await bar }}
return { cls }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > single line conditions 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
if (false) (
  ([__temp,__restore] = _withAsyncContext(() => foo())),
  await __temp,
  __restore()
)
return {  }
}

}"
`;

exports[`SFC compile <script setup> > async/await detection > variable 1`] = `
"import { withAsyncContext as _withAsyncContext } from 'vue'

export default {
  async setup(__props, { expose: __expose }) {
  __expose();

let __temp, __restore
const a = 1 + ((
  ([__temp,__restore] = _withAsyncContext(() => foo)),
  __temp = await __temp,
  __restore(),
  __temp
))
return { a }
}

}"
`;

exports[`SFC compile <script setup> > binding analysis for destructure 1`] = `
"export default {
  setup(__props, { expose: __expose }) {
  __expose();

      const { foo, b: bar, ['x' + 'y']: baz, x: { y, zz: { z }}} = {}
      
return { foo, bar, baz, y, z }
}

}"
`;

exports[`SFC compile <script setup> > defineEmits() 1`] = `
"export default {
  emits: ['foo', 'bar'],
  setup(__props, { expose: __expose, emit: myEmit }) {
  __expose();



return { myEmit }
}

}"
`;

exports[`SFC compile <script setup> > defineExpose() 1`] = `
"export default {
  setup(__props, { expose: __expose }) {

__expose({ foo: 123 })

return {  }
}

}"
`;

exports[`SFC compile <script setup> > defineModel() > basic usage 1`] = `
"import { useModel as _useModel } from 'vue'

export default {
  props: {
    \\"modelValue\\": { required: true },
    \\"count\\": {},
  },
  emits: [\\"update:modelValue\\", \\"update:count\\"],
  setup(__props, { expose: __expose }) {
  __expose();

        const modelValue = _useModel(__props, \\"modelValue\\")
        const c = _useModel(__props, \\"count\\")
        
return { modelValue, c }
}

}"
`;

exports[`SFC compile <script setup> > defineModel() > w/ array props 1`] = `
"import { useModel as _useModel, mergeModels as _mergeModels } from 'vue'

export default {
  props: _mergeModels(['foo', 'bar'], {
    \\"count\\": {},
  }),
  emits: [\\"update:count\\"],
  setup(__props, { expose: __expose }) {
  __expose();

        
        const count = _useModel(__props, \\"count\\")
        
return { count }
}

}"
`;

exports[`SFC compile <script setup> > defineModel() > w/ defineProps and defineEmits 1`] = `
"import { useModel as _useModel, mergeModels as _mergeModels } from 'vue'

export default {
  props: _mergeModels({ foo: String }, {
    \\"modelValue\\": { default: 0 },
  }),
  emits: _mergeModels(['change'], [\\"update:modelValue\\"]),
  setup(__props, { expose: __expose }) {
  __expose();

        
        
        const count = _useModel(__props, \\"modelValue\\")
        
return { count }
}

}"
`;

exports[`SFC compile <script setup> > defineModel() > w/ local flag 1`] = `
"import { useModel as _useModel } from 'vue'
const local = true
        
export default {
  props: {
    \\"modelValue\\": { local: true, default: 1 },
    \\"bar\\": { [key]: true },
    \\"baz\\": { ...x },
    \\"qux\\": x,
    \\"foo2\\": { local: true, ...x },
    \\"hoist\\": { local },
  },
  emits: [\\"update:modelValue\\", \\"update:bar\\", \\"update:baz\\", \\"update:qux\\", \\"update:foo2\\", \\"update:hoist\\"],
  setup(__props, { expose: __expose }) {
  __expose();

        const foo = _useModel(__props, \\"modelValue\\", { local: true })
        const bar = _useModel(__props, \\"bar\\", { [key]: true })
        const baz = _useModel(__props, \\"baz\\", { ...x })
        const qux = _useModel(__props, \\"qux\\", x)

        const foo2 = _useModel(__props, \\"foo2\\", { local: true })

        const hoist = _useModel(__props, \\"hoist\\", { local })
        
return { foo, bar, baz, qux, foo2, local, hoist }
}

}"
`;

exports[`SFC compile <script setup> > defineOptions() > basic usage 1`] = `
"export default /*#__PURE__*/Object.assign({ name: 'FooApp' }, {
  setup(__props, { expose: __expose }) {
  __expose();

        
        
return {  }
}

})"
`;

exports[`SFC compile <script setup> > defineOptions() > empty argument 1`] = `
"export default {
  setup(__props, { expose: __expose }) {
  __expose();

        
        
return {  }
}

}"
`;

exports[`SFC compile <script setup> > defineProps w/ external definition 1`] = `
"import { propsModel } from './props'
    
export default {
  props: propsModel,
  setup(__props, { expose: __expose }) {
  __expose();

const props = __props;

    
    
return { props, get propsModel() { return propsModel } }
}

}"
`;

exports[`SFC compile <script setup> > defineProps w/ leading code 1`] = `
"import { x } from './x'
    
export default {
  props: {},
  setup(__props, { expose: __expose }) {
  __expose();

const props = __props;

    
return { props, get x() { return x } }
}

}"
`;

exports[`SFC compile <script setup> > defineProps() 1`] = `
"const bar = 1

export default {
  props: {
  foo: String
},
  setup(__props, { expose: __expose }) {
  __expose();

const props = __props;



return { props, bar }
}

}"
`;

exports[`SFC compile <script setup> > defineProps/defineEmits in multi-variable declaration (full removal) 1`] = `
"export default {
  props: ['item'],
  emits: ['a'],
  setup(__props, { expose: __expose, emit }) {
  __expose();

const props = __props;

    
    
return { props, emit }
}

}"
`;

exports[`SFC compile <script setup> > defineProps/defineEmits in multi-variable declaration 1`] = `
"export default {
  props: ['item'],
  emits: ['a'],
  setup(__props, { expose: __expose, emit }) {
  __expose();

const props = __props;

    const a = 1;
    
return { props, a, emit }
}

}"
`;

exports[`SFC compile <script setup> > defineProps/defineEmits in multi-variable declaration fix #6757  1`] = `
"export default {
  props: ['item'],
  emits: ['a'],
  setup(__props, { expose: __expose, emit }) {
  __expose();

const props = __props;

    const a = 1;
    
return { a, props, emit }
}

}"
`;

exports[`SFC compile <script setup> > defineProps/defineEmits in multi-variable declaration fix #7422 1`] = `
"export default {
  props: ['item'],
  emits: ['foo'],
  setup(__props, { expose: __expose, emit: emits }) {
  __expose();

const props = __props;

    const a = 0,
          b = 0;
    
return { props, emits, a, b }
}

}"
`;

exports[`SFC compile <script setup> > dev mode import usage check > TS annotations 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { Foo, Bar, Baz, Qux, Fred } from './x'
        const a = 1
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        function b() {}
        
return { a, b, get Baz() { return Baz } }
}

})"
`;

exports[`SFC compile <script setup> > dev mode import usage check > attribute expressions 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { bar, baz } from './x'
        const cond = true
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { cond, get bar() { return bar }, get baz() { return baz } }
}

})"
`;

exports[`SFC compile <script setup> > dev mode import usage check > components 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { FooBar, FooBaz, FooQux, foo } from './x'
        const fooBar: FooBar = 1
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { fooBar, get FooBaz() { return FooBaz }, get FooQux() { return FooQux }, get foo() { return foo } }
}

})"
`;

exports[`SFC compile <script setup> > dev mode import usage check > directive 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { vMyDir } from './x'
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { get vMyDir() { return vMyDir } }
}

})"
`;

exports[`SFC compile <script setup> > dev mode import usage check > js template string interpolations 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { VAR, VAR2, VAR3 } from './x'
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { get VAR() { return VAR }, get VAR3() { return VAR3 } }
}

})"
`;

exports[`SFC compile <script setup> > dev mode import usage check > last tag 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { FooBaz, Last } from './x'
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { get FooBaz() { return FooBaz }, get Last() { return Last } }
}

})"
`;

exports[`SFC compile <script setup> > dev mode import usage check > vue interpolations 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import { x, y, z, x$y } from './x'
      
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

      
return { get x() { return x }, get z() { return z }, get x$y() { return x$y } }
}

})"
`;

exports[`SFC compile <script setup> > errors > should allow defineProps/Emit() referencing imported binding 1`] = `
"import { bar } from './bar'
        
export default {
  props: {
          foo: {
            default: () => bar
          }
        },
  emits: {
          foo: () => bar > 1
        },
  setup(__props, { expose: __expose }) {
  __expose();

        
        
        
return { get bar() { return bar } }
}

}"
`;

exports[`SFC compile <script setup> > errors > should allow defineProps/Emit() referencing scope var 1`] = `
"const bar = 1
          
export default {
  props: {
            foo: {
              default: bar => bar + 1
            }
          },
  emits: {
            foo: bar => bar > 1
          },
  setup(__props, { expose: __expose }) {
  __expose();

          
          
        
return { bar }
}

}"
`;

exports[`SFC compile <script setup> > imports > dedupe between user & helper 1`] = `
"import { ref as _ref } from 'vue'
import { ref } from 'vue'
      
export default {
  setup(__props, { expose: __expose }) {
  __expose();

      let foo = _ref(1)
      
return { foo, ref }
}

}"
`;

exports[`SFC compile <script setup> > imports > import dedupe between <script> and <script setup> 1`] = `
"import { x } from './x'
        
export default {
  setup(__props, { expose: __expose }) {
  __expose();

        x()
        
return { get x() { return x } }
}

}"
`;

exports[`SFC compile <script setup> > imports > should allow defineProps/Emit at the start of imports 1`] = `
"import { ref } from 'vue'
      
export default {
  props: ['foo'],
  emits: ['bar'],
  setup(__props, { expose: __expose }) {
  __expose();

      
      
      const r = ref(0)
      
return { r, ref }
}

}"
`;

exports[`SFC compile <script setup> > imports > should extract comment for import or type declarations 1`] = `
"import a from 'a' // comment
        import b from 'b'
        
export default {
  setup(__props, { expose: __expose }) {
  __expose();

        
return { get a() { return a }, get b() { return b } }
}

}"
`;

exports[`SFC compile <script setup> > imports > should hoist and expose imports 1`] = `
"import { ref } from 'vue'
          import 'foo/css'
        
export default {
  setup(__props, { expose: __expose }) {
  __expose();

          
return { ref }
}

}"
`;

exports[`SFC compile <script setup> > imports > should support module string names syntax 1`] = `
"import { \\"üòè\\" as foo } from './foo'
      
export default {
  setup(__props, { expose: __expose }) {
  __expose();

        
return { get foo() { return foo } }
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > avoid unref() when necessary 1`] = `
"import { unref as _unref, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, withCtx as _withCtx, createVNode as _createVNode, createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

import { ref } from 'vue'
        import Foo, { bar } from './Foo.vue'
        import other from './util'
        import * as tree from './tree'
        
export default {
  setup(__props) {

        const count = ref(0)
        const constant = {}
        const maybe = foo()
        let lett = 1
        function fn() {}
        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _createVNode(Foo, null, {
      default: _withCtx(() => [
        _createTextVNode(_toDisplayString(_unref(bar)), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }),
    _createElementVNode(\\"div\\", { onClick: fn }, _toDisplayString(count.value) + \\" \\" + _toDisplayString(constant) + \\" \\" + _toDisplayString(_unref(maybe)) + \\" \\" + _toDisplayString(_unref(lett)) + \\" \\" + _toDisplayString(_unref(other)), 1 /* TEXT */),
    _createTextVNode(\\" \\" + _toDisplayString(tree.foo()), 1 /* TEXT */)
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > referencing scope components and directives 1`] = `
"import { unref as _unref, createElementVNode as _createElementVNode, withDirectives as _withDirectives, createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

import ChildComp from './Child.vue'
        import SomeOtherComp from './Other.vue'
        import vMyDir from './my-dir'
        
export default {
  setup(__props) {

        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _withDirectives(_createElementVNode(\\"div\\", null, null, 512 /* NEED_PATCH */), [
      [_unref(vMyDir)]
    ]),
    _createVNode(ChildComp),
    _createVNode(SomeOtherComp)
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > should work 1`] = `
"import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

const _hoisted_1 = /*#__PURE__*/_createElementVNode(\\"div\\", null, \\"static\\", -1 /* HOISTED */)

import { ref } from 'vue'
        
export default {
  setup(__props) {

        const count = ref(0)
        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _createElementVNode(\\"div\\", null, _toDisplayString(count.value), 1 /* TEXT */),
    _hoisted_1
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > ssr codegen 1`] = `
"import { ssrRenderAttrs as _ssrRenderAttrs, ssrInterpolate as _ssrInterpolate } from \\"vue/server-renderer\\"

import { ref } from 'vue'
        
export default {
  __ssrInlineRender: true,
  setup(__props) {

        const count = ref(0)
        
return (_ctx, _push, _parent, _attrs) => {
  const _cssVars = { style: {
  \\"--xxxxxxxx-count\\": (count.value)
}}
  _push(\`<!--[--><div\${
    _ssrRenderAttrs(_cssVars)
  }>\${
    _ssrInterpolate(count.value)
  }</div><div\${
    _ssrRenderAttrs(_cssVars)
  }>static</div><!--]-->\`)
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > template assignment expression codegen 1`] = `
"import { createElementVNode as _createElementVNode, isRef as _isRef, unref as _unref, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

import { ref } from 'vue'
        
export default {
  setup(__props) {

        const count = ref(0)
        const maybe = foo()
        let lett = 1
        let v = ref(1)
        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _createElementVNode(\\"div\\", {
      onClick: _cache[0] || (_cache[0] = $event => (count.value = 1))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[1] || (_cache[1] = $event => (maybe.value = count.value))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[2] || (_cache[2] = $event => (_isRef(lett) ? lett.value = count.value : lett = count.value))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[3] || (_cache[3] = $event => (_isRef(v) ? v.value += 1 : v += 1))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[4] || (_cache[4] = $event => (_isRef(v) ? v.value -= 1 : v -= 1))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[5] || (_cache[5] = () => {
              let a = '' + _unref(lett)
              _isRef(v) ? v.value = a : v = a
           })
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[6] || (_cache[6] = () => {
              // nested scopes
              (()=>{
                let x = _ctx.a
                (()=>{
                  let z = x
                  let z2 = z
                })
                let lz = _ctx.z
              })
              _isRef(v) ? v.value = _ctx.a : v = _ctx.a
           })
    })
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > template destructure assignment codegen 1`] = `
"import { createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

import { ref } from 'vue'
        
export default {
  setup(__props) {

        const val = {}
        const count = ref(0)
        const maybe = foo()
        let lett = 1
        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _createElementVNode(\\"div\\", {
      onClick: _cache[0] || (_cache[0] = $event => (({ count: count.value } = val)))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[1] || (_cache[1] = $event => ([maybe.value] = val))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[2] || (_cache[2] = $event => (({ lett: lett } = val)))
    })
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > template update expression codegen 1`] = `
"import { createElementVNode as _createElementVNode, isRef as _isRef, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

import { ref } from 'vue'
        
export default {
  setup(__props) {

        const count = ref(0)
        const maybe = foo()
        let lett = 1
        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _createElementVNode(\\"div\\", {
      onClick: _cache[0] || (_cache[0] = $event => (count.value++))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[1] || (_cache[1] = $event => (--count.value))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[2] || (_cache[2] = $event => (maybe.value++))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[3] || (_cache[3] = $event => (--maybe.value))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[4] || (_cache[4] = $event => (_isRef(lett) ? lett.value++ : lett++))
    }),
    _createElementVNode(\\"div\\", {
      onClick: _cache[5] || (_cache[5] = $event => (_isRef(lett) ? --lett.value : --lett))
    })
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > v-model codegen 1`] = `
"import { vModelText as _vModelText, createElementVNode as _createElementVNode, withDirectives as _withDirectives, unref as _unref, isRef as _isRef, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \\"vue\\"

import { ref } from 'vue'
        
export default {
  setup(__props) {

        const count = ref(0)
        const maybe = foo()
        let lett = 1
        
return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    _withDirectives(_createElementVNode(\\"input\\", {
      \\"onUpdate:modelValue\\": _cache[0] || (_cache[0] = $event => ((count).value = $event))
    }, null, 512 /* NEED_PATCH */), [
      [_vModelText, count.value]
    ]),
    _withDirectives(_createElementVNode(\\"input\\", {
      \\"onUpdate:modelValue\\": _cache[1] || (_cache[1] = $event => (_isRef(maybe) ? (maybe).value = $event : null))
    }, null, 512 /* NEED_PATCH */), [
      [_vModelText, _unref(maybe)]
    ]),
    _withDirectives(_createElementVNode(\\"input\\", {
      \\"onUpdate:modelValue\\": _cache[2] || (_cache[2] = $event => (_isRef(lett) ? (lett).value = $event : lett = $event))
    }, null, 512 /* NEED_PATCH */), [
      [_vModelText, _unref(lett)]
    ])
  ], 64 /* STABLE_FRAGMENT */))
}
}

}"
`;

exports[`SFC compile <script setup> > inlineTemplate mode > with defineExpose() 1`] = `
"export default {
  setup(__props, { expose: __expose }) {

        const count = ref(0)
        __expose({ count })
        
return () => {}
}

}"
`;

exports[`SFC compile <script setup> > should compile JS syntax 1`] = `
"const a = 1
      const b = 2
      
export default {
  setup(__props, { expose: __expose }) {
  __expose();

      
return { a, b }
}

}"
`;

exports[`SFC compile <script setup> > should expose top level declarations 1`] = `
"import { x } from './x'
      
      import { xx } from './x'
      let aa = 1
      const bb = 2
      function cc() {}
      class dd {}
      

export default {
  setup(__props, { expose: __expose }) {
  __expose();

      let a = 1
      const b = 2
      function c() {}
      class d {}
      
return { get aa() { return aa }, set aa(v) { aa = v }, bb, cc, dd, get a() { return a }, set a(v) { a = v }, b, c, d, get xx() { return xx }, get x() { return x } }
}

}"
`;

exports[`SFC compile <script setup> > with TypeScript > const Enum 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
const enum Foo { A = 123 }
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { Foo }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (exported interface) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
export interface Emits { (e: 'foo' | 'bar'): void }
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (exported type alias) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
export type Emits = { (e: 'foo' | 'bar'): void }
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (interface ts type) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
interface Emits { (e: 'foo'): void }
      
export default /*#__PURE__*/_defineComponent({
  emits: ['foo'],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (interface) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
interface Emits { (e: 'foo' | 'bar'): void }
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (property syntax string literal) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo:bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (property syntax) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (referenced exported function type) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
export type Emits = (e: 'foo' | 'bar') => void
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (referenced function type) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
type Emits = (e: 'foo' | 'bar') => void
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (type alias) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
type Emits = { (e: 'foo' | 'bar'): void }
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type (type literal w/ call signatures) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\", \\"baz\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineEmits w/ type from normal script 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

        export interface Emits { (e: 'foo' | 'bar'): void }
      
export default /*#__PURE__*/_defineComponent({
  emits: [\\"foo\\", \\"bar\\"],
  setup(__props, { expose: __expose, emit }) {
  __expose();

      
      
return { emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineModel() > basic usage 1`] = `
"import { useModel as _useModel, defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: {
    \\"modelValue\\": { type: [Boolean, String] },
    \\"count\\": { type: Number },
    \\"disabled\\": { type: Number, ...{ required: false } },
    \\"any\\": { type: Boolean, skipCheck: true },
  },
  emits: [\\"update:modelValue\\", \\"update:count\\", \\"update:disabled\\", \\"update:any\\"],
  setup(__props, { expose: __expose }) {
  __expose();

          const modelValue = _useModel(__props, \\"modelValue\\")
          const count = _useModel(__props, \\"count\\")
          const disabled = _useModel(__props, \\"disabled\\")
          const any = _useModel(__props, \\"any\\")
          
return { modelValue, count, disabled, any }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineModel() > w/ production mode 1`] = `
"import { useModel as _useModel, defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: {
    \\"modelValue\\": { type: Boolean },
    \\"fn\\": {},
    \\"fnWithDefault\\": { type: Function, ...{ default: () => null } },
    \\"str\\": {},
    \\"optional\\": { required: false },
  },
  emits: [\\"update:modelValue\\", \\"update:fn\\", \\"update:fnWithDefault\\", \\"update:str\\", \\"update:optional\\"],
  setup(__props, { expose: __expose }) {
  __expose();

          const modelValue = _useModel(__props, \\"modelValue\\")
          const fn = _useModel(__props, \\"fn\\")
          const fnWithDefault = _useModel(__props, \\"fnWithDefault\\")
          const str = _useModel(__props, \\"str\\")
          const optional = _useModel(__props, \\"optional\\")
          
return { modelValue, fn, fnWithDefault, str, optional }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ TS assertion 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: ['foo'],
  setup(__props, { expose: __expose }) {
  __expose();

        
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ exported interface 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
export interface Props { x?: number }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    x: { type: Number, required: false }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

      
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ exported interface in normal script 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

        export interface Props { x?: number }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    x: { type: Number, required: false }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

        
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ exported type alias 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
export type Props = { x?: number }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    x: { type: Number, required: false }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

      
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ extends interface 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
interface Bar extends Foo { y?: number }
        interface Props extends Bar {
          z: number
          y: string
        }
        
        interface Foo { x?: number }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    z: { type: Number, required: true },
    y: { type: String, required: true },
    x: { type: Number, required: false }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

        
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ interface 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
interface Props { x?: number }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    x: { type: Number, required: false }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

      
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ type 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
interface Test {}

      type Alias = number[]

      
export default /*#__PURE__*/_defineComponent({
  props: {
    string: { type: String, required: true },
    number: { type: Number, required: true },
    boolean: { type: Boolean, required: true },
    object: { type: Object, required: true },
    objectLiteral: { type: Object, required: true },
    fn: { type: Function, required: true },
    functionRef: { type: Function, required: true },
    objectRef: { type: Object, required: true },
    dateTime: { type: Date, required: true },
    array: { type: Array, required: true },
    arrayRef: { type: Array, required: true },
    tuple: { type: Array, required: true },
    set: { type: Set, required: true },
    literal: { type: String, required: true },
    optional: { type: null, required: false },
    recordRef: { type: Object, required: true },
    interface: { type: Object, required: true },
    alias: { type: Array, required: true },
    method: { type: Function, required: true },
    symbol: { type: Symbol, required: true },
    extract: { type: Number, required: true },
    exclude: { type: [Number, Boolean], required: true },
    uppercase: { type: String, required: true },
    params: { type: Array, required: true },
    nonNull: { type: String, required: true },
    objectOrFn: { type: [Function, Object], required: true },
    union: { type: [String, Number], required: true },
    literalUnion: { type: String, required: true },
    literalUnionNumber: { type: Number, required: true },
    literalUnionMixed: { type: [String, Number, Boolean], required: true },
    intersection: { type: Object, required: true },
    intersection2: { type: String, required: true },
    foo: { type: [Function, null], required: true },
    unknown: { type: null, required: true },
    unknownUnion: { type: null, required: true },
    unknownIntersection: { type: Object, required: true },
    unknownUnionWithBoolean: { type: Boolean, required: true, skipCheck: true },
    unknownUnionWithFunction: { type: Function, required: true, skipCheck: true }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

      
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps w/ type alias 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
type Props = { x?: number }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    x: { type: Number, required: false }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

      
      
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineProps/Emit w/ runtime options 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: { foo: String },
  emits: ['a', 'b'],
  setup(__props, { expose: __expose, emit }) {
  __expose();

const props = __props;




return { props, emit }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineSlots() > basic usage 1`] = `
"import { useSlots as _useSlots, defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

          const slots = _useSlots()
          
return { slots }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > defineSlots() > w/o generic params 1`] = `
"import { useSlots as _useSlots } from 'vue'

export default {
  setup(__props, { expose: __expose }) {
  __expose();

          const slots = _useSlots()
          
return { slots }
}

}"
`;

exports[`SFC compile <script setup> > with TypeScript > defineSlots() > w/o return value 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

          
          
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > hoist type declarations 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
export interface Foo {}
        type Bar = {}
      
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return {  }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > import type 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
import type { Foo } from './main.ts'
        import { type Bar, Baz } from './main.ts'
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { get Baz() { return Baz } }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > runtime Enum 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
enum Foo { A = 123 }
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        
return { Foo }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > runtime Enum in normal script 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

          export enum D { D = \\"D\\" }
          const enum C { C = \\"C\\" }
          enum B { B = \\"B\\" }
        
export default /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

        enum Foo { A = 123 }
        
return { D, C, B, Foo }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults (dynamic) 1`] = `
"import { mergeDefaults as _mergeDefaults, defineComponent as _defineComponent } from 'vue'
import { defaults } from './foo'
      
export default /*#__PURE__*/_defineComponent({
  props: _mergeDefaults({
    foo: { type: String, required: false },
    bar: { type: Number, required: false },
    baz: { type: Boolean, required: true }
  }, { ...defaults }),
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

      
      
return { props, get defaults() { return defaults } }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults (dynamic) w/ production mode 1`] = `
"import { mergeDefaults as _mergeDefaults, defineComponent as _defineComponent } from 'vue'
import { defaults } from './foo'
      
export default /*#__PURE__*/_defineComponent({
  props: _mergeDefaults({
    foo: { type: Function },
    bar: { type: Boolean },
    baz: { type: [Boolean, Function] },
    qux: {}
  }, { ...defaults }),
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

      
      
return { props, get defaults() { return defaults } }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults (reference) 1`] = `
"import { mergeDefaults as _mergeDefaults, defineComponent as _defineComponent } from 'vue'
import { defaults } from './foo'
      
export default /*#__PURE__*/_defineComponent({
  props: _mergeDefaults({
    foo: { type: String, required: false },
    bar: { type: Number, required: false },
    baz: { type: Boolean, required: true }
  }, defaults),
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

      
      
return { props, get defaults() { return defaults } }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults (static) + normal script 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

        interface Props {
          a?: string;
        }
      
export default /*#__PURE__*/_defineComponent({
  props: {
    a: { type: String, required: false, default: \\"a\\" }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

        
      
return { props }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults (static) 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: {
    foo: { type: String, required: false, default: 'hi' },
    bar: { type: Number, required: false },
    baz: { type: Boolean, required: true },
    qux: { type: Function, required: false, default() { return 1 } },
    quux: { type: Function, required: false, default() { } },
    quuxx: { type: Promise, required: false, async default() { return await Promise.resolve('hi') } },
    fred: { type: String, required: false, get default() { return 'fred' } }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

      
      
return { props }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults (static) w/ production mode 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: {
    foo: {},
    bar: { type: Boolean },
    baz: { type: [Boolean, Function], default: true },
    qux: { default: 'hi' }
  },
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

      
      
return { props }
}

})"
`;

exports[`SFC compile <script setup> > with TypeScript > withDefaults w/ dynamic object method 1`] = `
"import { mergeDefaults as _mergeDefaults, defineComponent as _defineComponent } from 'vue'

export default /*#__PURE__*/_defineComponent({
  props: _mergeDefaults({
    foo: { type: Function, required: false }
  }, {
        ['fo' + 'o']() { return 'foo' }
      }),
  setup(__props: any, { expose: __expose }) {
  __expose();

const props = __props;

      
      
return { props }
}

})"
`;

exports[`SFC genDefaultAs > <script setup> only 1`] = `
"const a = 1
      
const _sfc_ = {
  setup(__props, { expose: __expose }) {
  __expose();

      
return { a }
}

}"
`;

exports[`SFC genDefaultAs > <script setup> only w/ ts 1`] = `
"import { defineComponent as _defineComponent } from 'vue'
const a = 1
      
const _sfc_ = /*#__PURE__*/_defineComponent({
  setup(__props, { expose: __expose }) {
  __expose();

      
return { a }
}

})"
`;

exports[`SFC genDefaultAs > <script> + <script setup> 1`] = `
"const __default__ = {}
      
const _sfc_ = /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

      const a = 1
      
return { a }
}

})"
`;

exports[`SFC genDefaultAs > <script> + <script setup> 2`] = `
"const __default__ = {}
      
const _sfc_ = /*#__PURE__*/Object.assign(__default__, {
  setup(__props, { expose: __expose }) {
  __expose();

      const a = 1
      
return { a }
}

})"
`;

exports[`SFC genDefaultAs > <script> + <script setup> w/ ts 1`] = `
"import { defineComponent as _defineComponent } from 'vue'

      const __default__ = {}
      
const _sfc_ = /*#__PURE__*/_defineComponent({
  ...__default__,
  setup(__props, { expose: __expose }) {
  __expose();

      const a = 1
      
return { a }
}

})"
`;

exports[`SFC genDefaultAs > normal <script> only 1`] = `
"
      const _sfc_ = {}
      "
`;

exports[`SFC genDefaultAs > normal <script> w/ cssVars 1`] = `
"
      const _sfc_ = {}
      
import { useCssVars as _useCssVars } from 'vue'
const __injectCSSVars__ = () => {
_useCssVars(_ctx => ({
  \\"xxxxxxxx-x\\": (_ctx.x)
}))}
const __setup__ = _sfc_.setup
_sfc_.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
"
`;
