import {
  EMPTY_ARR,
  NO,
  YES,
  camelize,
  hasOwn,
  isArray,
  isFunction,
  isString,
} from '@vue/shared'
import type { VaporComponent, VaporComponentInstance } from './component'
import {
  type NormalizedPropsOptions,
  baseNormalizePropsOptions,
  currentInstance,
  isEmitListener,
  popWarningContext,
  pushWarningContext,
  resolvePropValue,
  setCurrentInstance,
  validateProps,
  warn,
} from '@vue/runtime-dom'
import {
  type ComputedRef,
  ReactiveFlags,
  computed,
  onScopeDispose,
} from '@vue/reactivity'
import { normalizeEmitsOptions } from './componentEmits'
import { renderEffect } from './renderEffect'
import { pauseTracking, resetTracking } from '@vue/reactivity'
import type { interopKey } from './vdomInterop'

export type RawProps = Record<string, () => unknown> & {
  // generated by compiler for :[key]="x" or v-bind="x"
  $?: DynamicPropsSource[] & { [interopKey]?: boolean }
}

export type DynamicPropsSource =
  | (() => Record<string, unknown>)
  | Record<string, () => unknown>

export function resolveSource(
  source: Record<string, any> | (() => Record<string, any>),
): Record<string, any> {
  return isFunction(source)
    ? resolveFunctionSource(source as () => Record<string, any>)
    : source
}

export function resolveFunctionSource<T>(
  source: (() => T) & { _cache?: ComputedRef<T> },
): T {
  // use existing cache if available
  if (source._cache) {
    return source._cache.value
  }

  // source function is defined in the parent component, so it should be
  // executed in the parent's context. currentInstance is the child component
  // (the one accessing props/slots), so we use parent to get the component
  // where source was defined.
  const parent = currentInstance && currentInstance.parent
  if (parent) {
    source._cache = computed(() => {
      const prev = setCurrentInstance(parent)
      try {
        return source()
      } finally {
        setCurrentInstance(...prev)
      }
    })
    onScopeDispose(() => (source._cache = undefined))
    return source._cache.value
  }

  // no parent, no cache - just call directly
  return source()
}

export function getPropsProxyHandlers(
  comp: VaporComponent,
  once?: boolean,
): [
  ProxyHandler<VaporComponentInstance> | null,
  ProxyHandler<VaporComponentInstance>,
] {
  if (comp.__propsHandlers) {
    return comp.__propsHandlers
  }
  const propsOptions = normalizePropsOptions(comp)[0]
  const emitsOptions = normalizeEmitsOptions(comp)
  const isProp = (
    propsOptions
      ? (key: string | symbol) =>
          isString(key) && hasOwn(propsOptions, camelize(key))
      : NO
  ) as (key: string | symbol) => key is string
  const isAttr = propsOptions
    ? (key: string) =>
        key !== '$' && !isProp(key) && !isEmitListener(emitsOptions, key)
    : YES

  const getProp = (instance: VaporComponentInstance, key: string | symbol) => {
    // this enables direct watching of props and prevents `Invalid watch source` DEV warnings.
    if (key === ReactiveFlags.IS_REACTIVE) return true

    if (!isProp(key)) return
    const rawProps = instance.rawProps
    const dynamicSources = rawProps.$
    if (dynamicSources) {
      let i = dynamicSources.length
      let source, isDynamic, rawKey
      while (i--) {
        source = dynamicSources[i]
        isDynamic = isFunction(source)
        source = isDynamic
          ? (resolveFunctionSource(
              source as () => Record<string, unknown>,
            ) as any)
          : source
        for (rawKey in source) {
          if (camelize(rawKey) === key) {
            return resolvePropValue(
              propsOptions!,
              key,
              isDynamic
                ? source[rawKey]
                : resolveFunctionSource(source[rawKey]),
              instance,
              resolveDefault,
            )
          }
        }
      }
    }
    for (const rawKey in rawProps) {
      if (camelize(rawKey) === key) {
        return resolvePropValue(
          propsOptions!,
          key,
          resolveSource(rawProps[rawKey]),
          instance,
          resolveDefault,
        )
      }
    }
    return resolvePropValue(
      propsOptions!,
      key,
      undefined,
      instance,
      resolveDefault,
      true,
    )
  }

  const withOnceCache = <
    T extends (instance: VaporComponentInstance, key: string | symbol) => any,
  >(
    getter: T,
  ): T => {
    return ((instance: VaporComponentInstance, key: string | symbol) => {
      const cache = instance.oncePropsCache || (instance.oncePropsCache = {})
      if (!(key in cache)) {
        pauseTracking()
        try {
          cache[key] = getter(instance, key)
        } finally {
          resetTracking()
        }
      }
      return cache[key]
    }) as T
  }

  const getOnceProp = withOnceCache(getProp)
  const propsHandlers = propsOptions
    ? ({
        get: (target, key) => (once ? getOnceProp : getProp)(target, key),
        has: (_, key) => isProp(key),
        ownKeys: () => Object.keys(propsOptions),
        getOwnPropertyDescriptor(target, key) {
          if (isProp(key)) {
            return {
              configurable: true,
              enumerable: true,
              get: () => (once ? getOnceProp : getProp)(target, key),
            }
          }
        },
      } satisfies ProxyHandler<VaporComponentInstance>)
    : null

  if (__DEV__ && propsOptions) {
    Object.assign(propsHandlers!, {
      set: propsSetDevTrap,
      deleteProperty: propsDeleteDevTrap,
    })
  }

  const getAttr = (target: RawProps, key: string) => {
    if (!isProp(key) && !isEmitListener(emitsOptions, key)) {
      return getAttrFromRawProps(target, key)
    }
  }

  const hasAttr = (target: RawProps, key: string) => {
    if (isAttr(key)) {
      return hasAttrFromRawProps(target, key)
    } else {
      return false
    }
  }

  const getOnceAttr = withOnceCache((instance, key) =>
    getAttr(instance.rawProps, key as string),
  )
  const attrsHandlers = {
    get: (target, key: string) =>
      once ? getOnceAttr(target, key) : getAttr(target.rawProps, key),
    has: (target, key: string) => hasAttr(target.rawProps, key),
    ownKeys: target => getKeysFromRawProps(target.rawProps).filter(isAttr),
    getOwnPropertyDescriptor(target, key: string) {
      if (hasAttr(target.rawProps, key)) {
        return {
          configurable: true,
          enumerable: true,
          get: () =>
            once ? getOnceAttr(target, key) : getAttr(target.rawProps, key),
        }
      }
    },
  } satisfies ProxyHandler<VaporComponentInstance>

  if (__DEV__) {
    Object.assign(attrsHandlers, {
      set: propsSetDevTrap,
      deleteProperty: propsDeleteDevTrap,
    })
  }

  return (comp.__propsHandlers = [propsHandlers, attrsHandlers])
}

export function getAttrFromRawProps(rawProps: RawProps, key: string): unknown {
  if (key === '$') return
  // need special merging behavior for class & style
  const merged = key === 'class' || key === 'style' ? ([] as any[]) : undefined
  const dynamicSources = rawProps.$
  if (dynamicSources) {
    let i = dynamicSources.length
    let source, isDynamic
    while (i--) {
      source = dynamicSources[i]
      isDynamic = isFunction(source)
      source = isDynamic
        ? resolveFunctionSource(source as () => Record<string, unknown>)
        : source
      if (source && hasOwn(source, key)) {
        const value = isDynamic
          ? source[key]
          : resolveFunctionSource(source[key])
        if (merged) {
          merged.push(value)
        } else {
          return value
        }
      }
    }
  }
  if (hasOwn(rawProps, key)) {
    const value = resolveSource(rawProps[key])
    if (merged) {
      merged.push(value)
    } else {
      return value
    }
  }
  if (merged && merged.length) {
    return merged
  }
}

export function hasAttrFromRawProps(rawProps: RawProps, key: string): boolean {
  if (key === '$') return false
  const dynamicSources = rawProps.$
  if (dynamicSources) {
    let i = dynamicSources.length
    while (i--) {
      const source = resolveSource(dynamicSources[i])
      if (source && hasOwn(source, key)) {
        return true
      }
    }
  }
  return hasOwn(rawProps, key)
}

export function getKeysFromRawProps(rawProps: RawProps): string[] {
  const keys: string[] = []
  for (const key in rawProps) {
    if (key !== '$') keys.push(key)
  }
  const dynamicSources = rawProps.$
  if (dynamicSources) {
    let i = dynamicSources.length
    let source
    while (i--) {
      source = isFunction(dynamicSources[i])
        ? resolveFunctionSource(
            dynamicSources[i] as () => Record<string, unknown>,
          )
        : dynamicSources[i]
      for (const key in source) {
        keys.push(key)
      }
    }
  }
  return Array.from(new Set(keys))
}

export function normalizePropsOptions(
  comp: VaporComponent,
): NormalizedPropsOptions {
  const cached = comp.__propsOptions
  if (cached) return cached

  const raw = comp.props
  if (!raw) return EMPTY_ARR as []

  const normalized: NormalizedPropsOptions[0] = {}
  const needCastKeys: NormalizedPropsOptions[1] = []
  baseNormalizePropsOptions(raw, normalized, needCastKeys)

  return (comp.__propsOptions = [normalized, needCastKeys])
}

function resolveDefault(
  factory: (props: Record<string, any>) => unknown,
  instance: VaporComponentInstance,
) {
  const prev = setCurrentInstance(instance)
  const res = factory.call(null, instance.props)
  setCurrentInstance(...prev)
  return res
}

export function hasFallthroughAttrs(
  comp: VaporComponent,
  rawProps: RawProps | null | undefined,
): boolean {
  if (rawProps) {
    // determine fallthrough
    if (rawProps.$ || !comp.props) {
      return true
    } else {
      // check if rawProps contains any keys not declared
      const propsOptions = normalizePropsOptions(comp)[0]!
      for (const key in rawProps) {
        if (!hasOwn(propsOptions, camelize(key))) {
          return true
        }
      }
    }
  }
  return false
}

/**
 * dev only
 */
export function setupPropsValidation(instance: VaporComponentInstance): void {
  const rawProps = instance.rawProps
  if (!rawProps) return
  renderEffect(() => {
    pushWarningContext(instance)
    validateProps(
      resolveDynamicProps(rawProps),
      instance.props,
      normalizePropsOptions(instance.type)[0]!,
    )
    popWarningContext()
  }, true /* noLifecycle */)
}

export function resolveDynamicProps(props: RawProps): Record<string, unknown> {
  const mergedRawProps: Record<string, any> = {}
  for (const key in props) {
    if (key !== '$') {
      mergedRawProps[key] = resolveSource(props[key])
    }
  }
  if (props.$) {
    for (const source of props.$) {
      const isDynamic = isFunction(source)
      const resolved = isDynamic ? resolveFunctionSource(source) : source
      for (const key in resolved) {
        const value = isDynamic
          ? resolved[key]
          : resolveFunctionSource(source[key])
        if (key === 'class' || key === 'style') {
          const existing = mergedRawProps[key]
          if (isArray(existing)) {
            existing.push(value)
          } else {
            mergedRawProps[key] = [existing, value]
          }
        } else {
          mergedRawProps[key] = value
        }
      }
    }
  }
  return mergedRawProps
}

function propsSetDevTrap(_: any, key: string | symbol) {
  warn(
    `Attempt to mutate prop ${JSON.stringify(key)} failed. Props are readonly.`,
  )
  return true
}

function propsDeleteDevTrap(_: any, key: string | symbol) {
  warn(
    `Attempt to delete prop ${JSON.stringify(key)} failed. Props are readonly.`,
  )
  return true
}

export const rawPropsProxyHandlers: ProxyHandler<RawProps> = {
  get: getAttrFromRawProps,
  has: hasAttrFromRawProps,
  ownKeys: getKeysFromRawProps,
  getOwnPropertyDescriptor(target, key: string) {
    if (hasAttrFromRawProps(target, key)) {
      return {
        configurable: true,
        enumerable: true,
        get: () => getAttrFromRawProps(target, key),
      }
    }
  },
}
